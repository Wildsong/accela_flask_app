version: '3.7'

# Starts three services,
#
# redis, a message queue
# webapp, a web app implemented with flask
# worker, a celery app
#

networks:
  proxy_net:
    name: proxy_net
    external: true

services:
  redis:
  # This image is based on Debian;
  # there is an image based on Alpine but it uses an old Redis release.
    image: redis:latest
#    env_file: docker.env
#    ports:
#      - "6379:6379" # This port only has to be visible inside this webapp.
    deploy:
      mode: global
      restart_policy:
        condition: on-failure
        delay: 5s
        window: 15s
    networks:
      proxy_net:
        aliases:
          - redis

  webapp:
    build:
      context: .
      dockerfile: Dockerfile
    image: wildsong/accela:latest
#    env_file: .env
    environment:
      - PYTHONPATH=/srv
      - FLASK_APP=start_app
#      VIRTUAL_HOST: ${FLASK_HOST}
#      VIRTUAL_PORT: ${FLASK_PORT}
#      NETWORK_ACCESS: internal
#      LETSENCRYPT_HOST: ${FLASK_HOST}
#      LETSENCRYPT_MAIL: ${MY_EMAIL}
      # without these, flask app cannot find redis.
      - CELERY_BROKER=redis://redis:6379/0
      - CELERY_BACKEND=redis://redis:6379/0
    command: ["flask", "run"]
    volumes:
      - .:/srv 
      - "/etc/localtime:/etc/localtime:ro"
      - "/etc/timezone:/etc/timezone:ro"
    ports:
      - 5001:5001
    user: app
    networks:
      proxy_net:
        aliases:
          - webapp

  worker:
    image: wildsong/accela:latest
    environment:
      - PYTHONPATH=/srv
      # without these, celery tries to connect to RabbitMQ instead of REDIS.
      - CELERY_BROKER=redis://redis:6379/0
      - CELERY_BACKEND=redis://redis:6379/0
    command: celery --app=celery_worker worker --loglevel=info
    volumes:
      - .:/srv
    user: app
    networks:
      proxy_net:
        aliases:
          - worker

#    healthcheck:
#      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
#      interval: 10s
#      timeout: 10s
#      retries: 3
#      start_period: 30s

